\section{Introduction}


%% must verify the entire chain of proofs-of-work, which grows
%% linearly over time. On the contrary, clients based on NIPoPoWs require resources
%% only logarithmic in the length of the blockchain.

%
Today, Bitcoin and Ethereum remain the two largest proof-of-work
cryptocurrencies by market cap. However, the ecosystem has grown diverse, with
dozens of viable ``altcoin'' competitors.
%
Given such an environment,  it becomes increasingly  important to be able to
efficiently handle  multiple blockchains by the same client and reliably
transfer assets between them.
%
%
%
%We envision our NIPoPoW protocol will form the basis of an
%efficient multi-blockchain client, which could efficiently support payments
%using hundreds of different cryptocurrencies.
%Our protocol improves the performance of client.
%blockchain protocols in general
%are increasingly used as components of larger systems.

The first objective requires optimizing the ``SPV client'' described in the
original Bitcoin paper~\cite{bitcoin} which requires processing an amount of
data growing linearly with the size of the blockchain (namely, the block
headers).
%
%% Cryptocurrencies such as Bitcoin~\cite{bitcoin}\cite{bitcoinsoftware} and
%% Ethereum~\cite{ethereum} are peer-to-peer networks that maintain a globally
%% consistent transaction ledger, using a consensus protocol based on proof-of-work
%% (PoW) puzzles~\cite{pow,hashcash}. Worker nodes called ``miners'' expend
%% computational work in order to reach agreement on the state of the network.
%% Clients on the network, such as mobile phone apps, must verify these
%% PoWs in order to determine the correct view of the network's state, something necessary
%% to transmit and receive payments correctly.

%% In this work we introduce, analyze and instantiate a new primitive,
%% Non-Interactive Proofs of Proof-of-Work (NIPoPoWs), which can be adapted into
%% existing cryptocurrencies to support more efficient clients. A traditional
%% blockchain client in order to check a certain blockchain property \anote{TODO: too abstract
%
The second objective has received  significant attention in the context of
``cross-chain'' applications, i.e., logical transactions that span multiple
separate blockchains. Simple cross-chain transactions are feasible today: the
most well-known is the atomic exchange~\cite{tiernolan,herlihy2018atomic}, e.g.,
a trade of bitcoin for ether. However, more sophisticated
applications~
\cite{interledger,DBLP:journals/corr/DilleyPWPGF16,
      lerner,drivechains,wood2016polkadot,buchman2016tendermint}
could be enabled by a more efficient proof process, which would allow the
blockchain of one cryptocurrency to embed a client of a separate cryptocurrency.
This concept, initially popularized by a proposal by Back et al.
~\cite{sidechains} can be used to avoid a difficult upgrade process: a new
blockchain with additional features, such as experimental opcodes, can be backed
by deposits in the original bitcoin currency, obviating the need to transfer
capital to the new cryptocurrency. As one example of cross-chain interfacing, we
describe an initial coin offering (ICO)~\cite{ico} which distributes tokens
issued on one blockchain, but allows paying for them using coins in another
blockchain.

% These examples illustrate that our solution is a key component for two important
% pillars needed for next-generation blockchains: \emph{interoperability} and
% \emph{scalability}. While we use bitcoin concretely as an example, any
% proof-of-work cryptocurrency can adopt our techniques.

\subsection{Our contributions}
Our main technical contribution is the introduction and instantiation of a new
cryptographic primitive called \textit{Non-Interactive} Proofs of Proof-of-Work
(NIPoPoW).

We present a formal model and a provably secure instantiation of NIPoPoWs. We
introduce the first formal security definitions of NIPoPoW protocols and their
security. Our proofs are in the Bitcoin backbone model~\cite{backbone}. Our
construction is the first secure Proof of Proof-of-Work (regardless of
interactivity), assuming honest majority. Furthermore, our solution is
non-interactive making it the first protocol of this kind.

We encode events and other information that is useful to blockchain clients in
the form of \emph{blockchain predicates}. We describe a large class of
predicates that can be proven which we call \emph{infix sensitive}. This enables
proving statements pertaining to the blockchain such as the fact that a
transaction took place (for payment verification), that a smart contract method
ran with certain parameters, or that a payment was made into an account.

We prove the proofs are optimistically succinct meaning that they are
logarithmic in size in honest conditions. We show that, in the optimistic model
of no adversarial mining power, succinctness can be achieved for even
\emph{adversarially-generated} proofs. Our definition fills the gap in terms of
security modeling and design that existed in previous proposals, e.g., the
notion of cumulative ``Dynamic Member Multisignature'' ~\cite{sidechains}.

We provide concrete parameterization and empirical analysis showing the savings
of our approach versus existing clients. Using real data from the Bitcoin and
other networks, we quantify the savings of NIPoPoWs over the previous techniques
of constructing SPV verifiers. For a multi-blockchain client that receives 100
payments per day, we offer a 90\% reduction in bandwidth compared to na\"ive
SPV.

In the Appendix, we propose a novel gradual deployment path for our scheme which
we term a \emph{velvet fork} and which can provide the benefits of our scheme
without requiring miner adoption unlike typical \emph{hard} or \emph{soft
forks}. This technique may be of independent interest for other protocols.

In summary, we make the following contributions:
\begin{enumerate}
  \item We construct the first \emph{provably secure} Proofs of Proof-of-Work
        and give a formal definition of security. We make them
        \emph{non-interactive}.
  \item We model \emph{blockchain predicates} and show which classes of
        predicates can be proven using our protocol.
  \item We create the first decentralized protocol which is secure against all
        adversaries and \emph{succinct} for non-mining adversaries.
  \item We provide \emph{experimental data} which measure the efficiency and
        security of our scheme as well as concrete parameters based on these
        experiments.
  \item We illustrate the practical value of our scheme by discussing further
        applications and presenting a mechanism for backwards-compatible
        deployment into existing blockchains, \emph{velvet forks}.
\end{enumerate}

\noindent
\textbf{Previous work.} The need for succinct clients was first identified by
Nakamoto in his original paper~\cite{bitcoin}. Predicates pertaining to events
occurring in the blockchain have been explored in the setting of
sidechains~\cite{sidechains} without a concrete protocol or definitions. It has
also been implemented for simple classes of predicates such as atomic
swaps~\cite{tiernolan,herlihy2018atomic}, which do not allow full
synchronization. Non-succinct certificates about proof-of-\emph{stake}
blockchains have been proposed in~\cite{gazi2019proof}, but their scheme is not
applicable to proof-of\emph{work}. The idea of superblocks we utilize in our
construction has been first described in the Bitcoin Forum~\cite{highway}. This
was also adopted by~\cite{KLS} to describe their \emph{Proofs of Proof-of-Work}.
Our scheme is comparable to theirs (cf. Section~\ref{sec:suffix}). We improve
upon their work, as their paper does not include a security definition and,
unlike ours, is interactive, which limits its applicability. Additionally, their
scheme is not secure (in fact our attack of Section~\ref{sec:attack} is
sufficient to break their scheme with overwhelming probability) nor succinct
against adversarial provers and does not allow the proof of generic predicates.
