\section{Gradual Deployment Paths}\label{sec:forks}

Existing cryptocurrencies can also benefit by adopting our construction as an
upgrade. We outline several possible upgrade paths. We also contribute a novel
upgrade approach, a ``velvet fork,'' which allows for gradual deployment without
harming unupgraded miners.

\noindent
\textbf{Hard Forks and Soft Forks.}
The obvious way to upgrade to add support for our protocol is a hard fork:
the block header is modified to include the interlink structure, and the
validation rules modified to require that new blocks (after a ``flag day'')
contain a correctly-formed interlink hash.

NIPoPoWs can also be implemented by a soft fork. A soft fork construction
requires including the interlink not in the block header, but in the coinbase
transaction. It is enough to only store a hash of the interlink structure. The
only requirement for the NIPoPoWs to work is that the PoW commits to all the
pointers within the interlink so that the adversary cannot cause a chain
reorganization. If we take that route, then each NIPoPoW will be required to
present not only the block header, but also a proof-of-inclusion path within the
Merkle tree of transactions proving that the coinbase transaction is indeed part
of the block. Once that is established, the coinbase data can be presented, and
the verifier will thereby know that the hash of the interlink data structure is
correct. Including such proofs-of-inclusion will only increase the NIPoPoW sizes
by a constant factor per block, allowing for the communication complexity to
remain polylogarithmic.

\noindent
\textbf{Velvet Forks.}
We now describe a novel upgrade path that avoids the need for a fork at all. The
key idea is that clients can make use of our scheme, even if only some blocks in
the blockchain include the interlink structure. Given that intuitively the
changes we will propose require no rule modifications to the consensus layer, we call this
technique a \emph{velvet fork}
\ifanonymous
  .
\else
  \footnote{After the manuscript of this paper appear on
  \emph{ePrint}, velvet forks were explored in a follow-up
  work\cite{velvet}}.
\fi

We require upgraded miners to include the interlink data structure in the form
of a new Merkle tree root hash in their coinbase data, similar to a soft fork.
An unupgraded miner will ignore this data as comments. We further require the
upgraded miners to accept all previously accepted blocks, regardless of whether
they have included the interlink data structure or not. Even if the interlink
data structure is included and contains invalid data, we require the upgraded
miners to accept their containing blocks. Malformed interlink data could be
simply of the wrong format, or the pointers could be pointing to superblocks of
incorrect levels. Furthermore, the pointers could be pointing to superblocks of
the correct level, but not to the most recent block. By requiring upgraded
miners to accept all such blocks, we do not modify the set of accepted blocks.
Therefore, the upgrade is simply a ``recommendation'' for miners and not an
actual change in the consensus rules. Hence, while a hard fork makes new
upgraded blocks invalid to unupgraded clients and a soft fork makes new
unupgraded blocks invalid to upgraded clients, the velvet fork has the effect
that blocks produced by either upgraded or unupgraded clients are valid for
either. In reality, the blockchain is never forked. Only the codebase is
upgraded, and the data on the blockchain is interpreted differently.

The reason this can work is because provers and verifiers of our protocol can
check the validity of the claims of miners who make false interlink chain
claims. An upgraded prover can check whether a block contains correct interlink
data and use it. If a block does not contain correct interlink data, the prover
can opt not to use those pointers in their proofs. The Verifier verifies all
claims of the prover, so adversarial miners cannot cause harm by including
invalid data. The one thing the Verifier cannot verify in terms of interlink
claims is whether the claimed superblock of a given level is the most recent
previous superblock of that level. However, an adversarial prover cannot make
use of that to construct winning proofs, as they are only able to present
shorter chains in that case. The honest prover can simply ignore such pointers
as if they were not included at all.

The velvet prover works as usual, but additionally stores the \emph{correct}
interlink for each block. The velvet $\chain\upchain$ operator is
implemented identically as before, except that instead of following the
interlink pointer blindly it now and creates a connection from $B$ back to the
most recent preceding $\mu$-superblock, by following the interlink pointer if it
is correct. Otherwise, it follows the previd link which is available in all
blocks, and recursively tries to follow the interlink pointer again from there.
The prover includes the auxiliary connecting nodes within the final proof. No
changes in the verifier are needed.

Velvet NIPoPoWs preserve security. Additionally, if a constant minority of
miners has upgraded their nodes, then succinctness is also preserved as there is
only a constant factor penalty.
