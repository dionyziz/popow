\section{Security}

The prior PoPoW protocol~\cite{KLS} designed to prevent Bahack-style
attacks~\cite{bahack}, where the adversary constructs ``lucky'' high-difficulty
superblocks without filling in the underlying proof-of-work in the lower levels.
Our protocol retains this highlevel approach, but adds a defense against the
double-spending attack of Section~\ref{sec:attack}. The attack is neutralized
since our verifier is more permissive, allowing the prover to construct a proof
that takes superquality ``goodness'' into account when comparing forks.

\begin{restatable}{theorem}{restateThmSecurity}
    \label{thm.security}
    Assuming honest majority, the non-interactive proofs-of-proof-of-work
    construction for $k$-stable monotonic suffix-sensitive predicates is secure
    with overwhelming probability in $\kappa$.
\end{restatable}

We will first give a sketch of the proof before getting into
details. Suppose an adversary produces a proof $\pi_\mathcal{A}$ and an honest
party produces a proof $\pi_B$ such that the two proofs cause the predicate $Q$
to evaluate to different values, while at the same time all honest parties have
agreed that the correct value is the one obtained by $\pi_B$. Because of
bitcoin's security, $\mathcal{A}$ will be unable to make these claims for an
actual underlying 0-level chain.

We now argue that the operator $\leq_m$ will
signal in favour of the honest parties.
Suppose $b$ is the LCA block between $\pi_\mathcal{A}$ and $\pi_B$. If the chain
forks at $b$, there can be no more adversarial blocks after $b$ than honest
blocks after $b$, provided there are at least $k$ honest blocks (due to the
Common Prefix property). We will now argue that, further, there can be no more
disjoint $\mu_\mathcal{A}$-level superblocks than honest $\mu_B$-level
superblocks after $b$.

To see this, let $b$ be an honest block generated at some round $r_1$ and let
the honest proof have been generated at some round $r_3$. Then take the sequence
of consecutive rounds $S = (r_1, \cdots, r_3)$. Because the verifier requires at
least $m$ blocks from each of the provers, the adversary must have $m$
$\mu_\mathcal{A}$-superblocks in $\pi_\mathcal{A}\{b:\}$ which are not in
$\pi_B\{b:\}$. Therefore, using a negative binomial tail bound argument, we see
that $|S|$ must be long; intuitively, it takes a long time to produce a lot of
blocks $|\pi_\mathcal{A}\{b:\}|$. Given that $|S|$ is long and that the honest
parties have more mining power, they must have been able to produce a longer
$\pi_B\{b:\}$ argument (of course, this comparison will have the superchain
lengths weighted by $2^{\mu_\mathcal{A}}, 2^{\mu_B}$ respectively). To prove
this, we use a binomial tail bound argument; intuitively, given a long time
$|S|$, a lot of $\mu_B$-superblocks $|\pi_B\{b:\}|$ will have been honestly
produced.

We therefore have a fixed value for the length of the adversarial argument, a
negative binomial random variable for the number of rounds, and a binomial
random variable for the length of the honest argument. By taking the
expectations of the above random variables and applying a Chernoff bound, we see
that the actual values will be close to their means with overwhelming
probability, completing the proof.

\paragraph{Remark.}
Observe that, while setting $m = 1$ ``preserves'' the proof-of-work in the sense
that expectations remain the same, the probability of an adversarial attack
becomes approximately proportional to the adversary power if the adversary
follows a suitable strategy (for a description of such a strategy, see the
parameterization section). With higher values of $m$, the probability of an
adversarial attack drops exponentially in $m$, even though they maintain
constant computational power, and hence satisfy a strong notion of security.

\paragraph{Proof of security. }
We now go on to formalize the above proof sketch.

Assume $t$ adversarial and $n$ total parties, each with $q$
PoW random oracle queries per round. We will call a query to the
RO $\mu$-\textit{successful} if the RO returns a value $h$
such that $h \leq 2^{-\mu}T$.

We define boolean random variables $X_r^\mu$, $Y_r^\mu$ and $Z_r^\mu$. Fix some
round $r$, query index $j$ and adversarial party index $k$ (out of $t$). If at
round $i$ an honest party obtains a PoW with $id < 2^{-\mu}T$, set $X_r^\mu =
1$, otherwise $X_r^\mu = 0$. If at round $r$ exactly one honest party obtains a
PoW with $id < 2^{-\mu}T$, set $Y_r^\mu = 1$, otherwise $Y_r^\mu = 0$. If at
round $r$ the $j$-th query of the $k$-th corrupted party is $\mu$-successful,
set $Z^\mu_{ijk} = 1$, otherwise $Z^\mu_{ijk} = 0$. Let $Z^\mu_r = \sum_{k=1}^t
\sum_{j=1}^q Z^\mu_{ijk}$. For a set of rounds $S$, let $X^\mu(S) = \sum_{r \in
S} X_r$ and similarly define $Y^\mu(S), Z^\mu(S)$.

\begin{definition} %{(Typical execution)}
    An execution of the protocol is $(\epsilon, \eta)$-\textit{typical} if:

    \textnormal{\bf Block counts don't deviate.}
    For all $\mu \geq 0$ and any set $S$ of consecutive rounds
    with $|S| \geq 2^\mu \eta\kappa$, we have:

    \begin{itemize}
        \item $(1 - \epsilon)E[X^\mu(S)] < X^\mu(S) < (1 + \epsilon)E[X^\mu(S)]$ and $(1 - \epsilon)E[Y^\mu(S)] < Y^\mu(s)$.
        \item $Z^\mu(S) < (1 + \epsilon)E[Z^\mu(S)]$.
    \end{itemize}

    \textnormal{\bf Round count doesn't deviate.}
    Let $S$ be a set of consecutive rounds such that $Z^\mu(S)
    \geq k$ for some security parameter $k$. Then $|S| \geq (1 -
    \epsilon)2^\mu\frac{k}{pqt}$ with overwhelming probability in $k$.

    \textnormal{\bf Chain regularity.}
    No insertions, no copies, and no predictions \cite{backbone} have occurred.
\end{definition}

\begin{theorem}[Typicality]
\label{thm.typicality}
Executions are $(\epsilon, \eta)$-typical with overwhelming
probability in $\kappa$.
\end{theorem}
\import{./}{proofs/typicality.tex}

The following lemma is at the heart of the security proof that will follow.

\begin{lemma}\label{lem.level-comparison}
    Suppose $S$ is a set of consecutive rounds $r_1 \ldots r_2$
    and $\chain_B$ is
    a chain adopted by an honest party at round $r_2$ of a typical execution.
    Let $\chain_B^S = \{b \in
    \chain_B: b \textnormal{ was generated during } S\}$. Let $\mu_\mathcal{A},
    \mu_B \in \mathbb{N}$. Suppose $\chain_B^S\upchain^{\mu_B}$ is good.
    Suppose $\chain'_\mathcal{A}$ is a $\mu_\mathcal{A}$-superchain containing
    only adversarially generated blocks generated during $S$ and suppose that
    $|\chain'_\mathcal{A}| \geq k$.
    Then
    $2^{\mu_\mathcal{A}}|\chain'_\mathcal{A}| < \frac{1}{3}2^{\mu_B}|\chain_B^S\upchain^{\mu_B}|$.
\end{lemma}
\import{./}{proofs/levelcomparison.tex}

\begin{definition}[Adequate level of honest proof]
Let $\pi$ be an honestly generated proof constructed upon some adopted chain
$\chain$ and let $b \in \pi$.

Then $\mu'$ is defined as  $\mu' = \max\{\mu: |\pi\{b:\}\upchain^\mu| \geq
\max(m + 1, (1 - \delta)2^{-\mu}|\pi\{b:\}\upchain^\mu\downchain|)\}$.
We call $\mu'$ the \textit{adequate} level of proof $\pi$ with respect to
block $b$ with security parameters $\delta$ and $m$. Note that the adequate
level of a proof is a function of both the proof $\pi$ and the chosen block $b$.
\end{definition}

\begin{restatable}{lemma}{restateThmAllBlocks}\label{lem.allblocks}
Let $\pi$ be some honest proof generated with security parameters $\delta, m$.
Let $\chain$ be the underlying chain, $b \in \chain$ be any block and $\mu'$ be
the adequate level of the proof with respect to $b$ and the same security
parameters.

Then $\chain\{b:\}\upchain^{\mu'} = \pi\{b:\}\upchain^{\mu'}$.
\end{restatable}
\import{./}{proofs/allblocks.tex}

\begin{lemma}
Suppose the verifier evaluates $\pi_\mathcal{A} \geq \pi_B$ in a protocol
interaction where $B$ is honest and assume during the comparison that the
compared level of the honest party is $\mu_B$. Let $b =
\textsf{LCA}(\pi_\mathcal{A}, \pi_B)$ and let $\mu_B'$ be the adequate
level of $\pi_B$ with respect to $b$. Then $\mu_B' \geq \mu_B$.
\end{lemma}
\import{./}{proofs/leveladequacy.tex}

% \noindent
% \textbf{Theorem \ref{thm.security}}
\restateThmSecurity*
\import{./}{proofs/security.tex}


\begin{remark}[Variance attacks]
\label{rmk.variance}
The critical issue addressed by this security proof is to avoid Bahack-style
attack \cite{bahack} where the adversary constructs ``lucky'' high-difficulty
superblocks without filling in the underlying proof-of-work in the lower
levels. Observe that, while setting $m = 1$ ``preserves'' the proof-of-work in
the sense that expectations remain the same, the probability of an adversarial
attack becomes approximately proportional to the adversary power if the
adversary follows a suitable strategy (for a description of such a strategy,
see the parameterization section). With higher values of $m$, the probability of
an adversarial attack drops exponentially in $m$, even though they maintain constant
computational power, and hence satisfy a strong notion of security.
\end{remark}

\begin{remark}
Intuitively, the attack of Section~\ref{sec:attack} is neutralized, because
our prover takes ``goodness'' of blockchains into account and the verifier
does not compare proofs strictly at the same level.
\end{remark}
