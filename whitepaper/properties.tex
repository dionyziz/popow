\subsection{Desired properties}

We now define two desired properties of a non-interactive blockchain proof
protocol, \emph{succinctness} and \emph{security}.

\begin{definition}{(Security)}
A \emph{blockchain proof protocol} $(P, V)$ about a predicate $Q$ is
\emph{secure} if for all environments and for all PPT adversaries $\mathcal{A}$
and for all rounds $r$, if all honest full nodes would agree about the value of
$Q$ at round $r$, then $V$ who receives a proof generated by an honest prover at
round $r$ as well as multiple other proofs produced by other honest provers and
the adversary at round $r$ arrives at that same truth value $Q$.
\end{definition}

\begin{figure}
    \caption{The truth value of a fixed predicate $Q$ about the blockchain, as
             seen from the point of view of $5$ honest nodes, drawn on the
             vertical axis, over time, drawn as the horizontal axis. The truth
             value evolves over time starting as \emph{false} at the beginning,
             indicated by a dashed red line. At some point in time $t_0$, the
             predicate is ready to be evaluated as \emph{true}, indicated by the
             solid blue line. The various honest nodes each realize this
             independently over a period of $\eta k$ duration, shaded in gray.
             The predicate remains \emph{false} for everyone before $t_0$ and
             \emph{true} for everyone after $t_0 + \eta k$.}
    \centering
    \iftwocolumn
        \includegraphics[width=0.5 \columnwidth,keepaspectratio]{figures/predicate-evolution.pdf}
    \else
        \includegraphics[width=0.5\columnwidth,keepaspectratio]{figures/predicate-evolution.pdf}
    \fi
    \label{fig.evolution}
\end{figure}


Some explanation is needed for the rationale of the above definition. The
parameter $\eta$ is borrowed from the Backbone~\cite{backbone} work and
indicates the rate at which new blocks are produced, i.e., the number of rounds
needed on average to produce a block. If the scheme is secure, this means that
the output of the verifier should match the output of a \emph{potential honest
full node}. However, in various executions, not all potential honest full node
behaviors will be instantiated. Therefore, we require that, if the output of the
proof verifier is \emph{true} then, consistently with honest behavior, all other
honest full nodes will converge to the value \emph{true}. Conversely, if the
output of the proof verifier is \emph{false} then, consistently with honest
behavior, all honest full nodes must have indicated \emph{false} sufficiently
long in the past. The period $\eta k$ is the period needed for obtaining
sufficient confirmations ($k$) in a blockchain system. A predicate's value has
the potential of being \emph{true} as seen by an honest party starting at time
$t_0$. Before time $t_0$, all honest parties agree that the predicate is
\emph{false}. It takes $\eta k$ time for all parties to agree that the predicate
is \emph{true}, which is certain after time $t_0 + \eta k$. The adversary may be
able to convince the verifier that the predicate has any value during the period
from $t_0$ to $t_0 + \eta k$. However, our security definition mandates that
before time $t_0$ the verifier will necessarily output \emph{false} and after
time $t_0 + \eta k$ the verifier will necessarily output \emph{true}.

\begin{remark}[Time of issuance]
  The above security definition strictly requires that all NIPoPoW proofs have
  all been generated at some round $r$. In a more realistic setting,
  NIPoPoW proofs could be generated for a period of time of a certain length
  $\eta k$. Without loss of generality, it can be assumed that, in such a
  setting, the honest party $P$ generates the NIPoPoW proof at time $r$ while
  the adversary generates her proof at time $r + \eta k$, gaining some
  advantage. The security definition can be altered to allow for such a setting
  by requiring the truth value to alter only within the period $r - 2\eta k$ to
  $r + 2\eta k$.
\end{remark}

\begin{definition}{(Succinctness)}
A \emph{blockchain proof protocol} $(P, V)$ about a predicate $Q$ is
\emph{succinct} if for all PPT provers $\mathcal{A}$, any proof $\pi$ produced
by $\mathcal{A}$ at some round $r$, the verifier $V$ only reads a
$O(polylog(r))$-sized portion of $\pi$.
\end{definition}

It is easy to construct a \emph{secure but not succinct} protocol for any
computable predicate $Q$: The prover provides the entire chain $\chain$ as a
proof and the verifier simply selects the longest chain: by the
\emph{common-prefix property} of the backbone protocol (c.f.~\cite{backbone}),
this is consistent with the view of every honest party (as long as $Q$ depends
only on a \emph{prefix} of the chain, as we explain in more detail shortly). In
fact this is how widely-used cryptocurrency clients (including SPV clients)
operate today.

It is also easy to build \emph{succinct but insecure} clients: The prover simply
sends the predicate value directly. This is roughly what hosted wallets
do~\cite{sok}.

The challenge we will solve is to provide a non-interactive protocol that at the
same time achieves security and (optimistic) succinctness over a large class of
useful predicates.
