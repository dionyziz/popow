\subsection{Desired properties}

We now define two desired properties of a non-interactive blockchain proof
protocol, \emph{succinctness} and \emph{security}.

\begin{definition}{(Security)}
A \emph{blockchain proof protocol} $(P, V)$ about a predicate $Q$ is
\emph{secure} if for all environments and for all PPT adversaries $\mathcal{A}$
and for all rounds $r$, if all honest full nodes would agree about the value of
$Q$ at round $r$, then $V$ who receives a proof generated by an honest prover at
round $r$ as well as multiple other proofs produced by other honest provers and
the adversary at round $r$ arrives at that same truth value $Q$.
\end{definition}

\begin{remark}
  In the strict formal setting of Backbone~\cite{backbone}, there are executions
  which due to technical reasons can omit a number of honest parties. Hence, the
  full formal definition of security must include a term $\eta$ which accounts
  for all \emph{potential} full nodes agreeing. The formulation with this term
  states that the value $Q$ that the honest full nodes agree on must not have
  \emph{recently changed} from true to false, as this indicates a period of
  uncertainty. Once this quantifiable period of uncertainty has passed and $Q$
  is \emph{confirmed}, only then are we concerned with the outcome of $V$. The
  exact technical details of this definition are available in the full version
  of our paper, accompanying the complete security proof.
\end{remark}

% \begin{remark}[Time of issuance]
%   The above security definition strictly requires that all NIPoPoW proofs have
%   all been generated at some round $r$. In a more realistic setting,
%   NIPoPoW proofs could be generated for a period of time of a certain length
%   $d$. Without loss of generality, it can be assumed that, in such a
%   setting, the honest party $P$ generates the NIPoPoW proof at time $r$ while
%   the adversary generates her proof at time $r + d$, gaining some
%   advantage. The security definition can be altered to accommodate for such a
%   setting.
% \end{remark}

\begin{definition}{(Succinctness)}
A \emph{blockchain proof protocol} $(P, V)$ about a predicate $Q$ is
\emph{succinct} if for all PPT provers $\mathcal{A}$, any proof $\pi$ produced
by $\mathcal{A}$ at some round $r$, the verifier $V$ only reads a
$O(polylog(r))$-sized portion of $\pi$.
\end{definition}

It is easy to construct a \emph{secure but not succinct} protocol for any
computable predicate $Q$: The prover provides the entire chain $\chain$ as a
proof and the verifier simply selects the longest chain: by the
\emph{common-prefix property} of the backbone protocol (c.f.~\cite{backbone}),
this is consistent with the view of every honest party (as long as $Q$ depends
only on a \emph{prefix} of the chain, as we explain in more detail shortly). In
fact this is how widely-used cryptocurrency clients (including SPV clients)
operate today.

It is also easy to build \emph{succinct but insecure} clients: The prover simply
sends the predicate value directly. This is roughly what hosted wallets
do~\cite{sok}.

The challenge we will solve is to provide a non-interactive protocol that at the
same time achieves security and succinctness over a large class of useful
predicates. We call this primitive a NIPoPoWs. Our particular instantiation for
NIPoPoWs is a \emph{superblock-based NIPoPoW construction}.
