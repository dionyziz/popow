\section{Model and Definitions}
\label{sec:model}
Our model is based on the ``backbone'' model for proof-of-work
cryptocurrencies~\cite{backbone}, extended with SPV. Following their model, we
assume
\emph{synchrony} (\emph{partial synchrony}
with \emph{bounded delay}~\cite{PSS} is left for future work)
and constant difficulty.

\subsection{Backbone model}

% AM:
%We define our problem in the setting of a blockchain client which is completely
%stateless beyond the knowledge of a common reference string, the genesis block.
%Without loss of generality, this single reference block could be any stable
%checkpoint block, either hard-coded in the client or obtained through a previous
%interaction with the network.

The entities on the blockchain network are of 3 kinds: (1) Miners, who try to
mine new blocks on top of the longest known blockchain and broadcast them as
soon as they are discovered. Miners commit new transactions they receive from clients. (2) Full nodes, who maintain the longest blockchain
without mining and also act as the provers in the network. (3) Verifiers or
stateless clients, who do not store the entire blockchain, but instead connect to provers and ask for proofs in regards to which
blockchain is the largest. The verifiers attempt to determine the value of a
predicate on these chains, for example whether a particular payment has been finalized.

Our main challenge is to design
a protocol so that clients can sieve through  the responses they receive from
the network and reach a conclusion that should never disagree with the
conclusion of a full  node who is faced with the same objective and infers it
from its local blockchain state.

We model proof-of-work discovery attempts by using a random oracle~\cite{RO}.
The random oracle produces $\kappa$-bit strings, where $\kappa$ is the system's
security parameter. The network is synchronized into numbered rounds, which
correspond to moments in time. $n$ denotes the total number of miners in the
game, while $t$ denotes the total number of adversarial miners. Each miner is
assumed to have equal mining power captured by the number of queries $q$
available per player to the random oracle per round, each query of which
succeeds independently with probability $p$ (a successful query produces a block
with valid proof-of-work). Mining pools and miners of different computing power
can be captured by assuming multiple players combine their computing power. This
is made explicit for the adversary, as they do not incur any network overhead to
achieve communication between adversarial miners. On the contrary, honest
players discovering a block must \emph{diffuse} it (broadcast it) to the
network at a given round and wait for it to be received by the rest of the
honest players at the beginning of the next round. A round during which an
honest block is diffused is called a \emph{successful round}; if the number of
honest blocks diffused is one, it is called a \emph{uniquely successful round}.
We assume there is an honest majority, i.e., that $t / n < 0.5$ with a constant
minimum gap~\cite{backbone}. We further assume the network is adversarial, but
there is no eclipsing attacks~\cite{heilman2015eclipse}. More specifically, we
allow the adversary to reorder messages transmitted at a particular round, to
inject new messages thereby capturing Sybil attacks~\cite{sybil}, but not to
drop messages. Each honest miner maintains a local chain $\chain$ which they
consider the current active blockchain. Upon receiving a different blockchain
from the network, the current active blockchain is changed if the received
blockchain is longer than the currently adopted one. Receiving a different
blockchain of the same length as the currently adopted one does not change the
adopted blockchain.

Blockchain blocks are generated by including the following data in them: $ctr$,
the nonce used to achieve the proof-of-work; $x$ the Merkle tree~\cite{merkle}
root of the transactions confirmed in this block; and
\emph{interlink}~\cite{KLS}, a vector containing pointers to previous blocks,
including the id of the previous block. The \emph{interlink} data structure
contains pointers to more blocks than just the previous block. We will explain
this further in Section~\ref{sec:consensus}. Given two hash functions $H$ and
$G$ modelled as random oracles, the id of a block is defined as $\textsf{id} =
H(ctr, G(x, \textsf{interlink}))$. In bitcoin's case, both $H$ and $G$ would be
SHA256.

\subsection{The prover and verifier model}
In our protocol, the nodes include a \emph{proof} along with their responses to
clients. We need to assume that clients are able to connect to at least one
correctly functioning node (i.e., that they cannot be eclipsed from the
network~\cite{heilman2015eclipse,hijackingbitcoin}). Each client makes the same
request to every node, and by verifying the proofs the client identifies the
correct response. Henceforth we will call clients \emph{verifiers} and nodes
\emph{provers}.
% Note that in the interactive protocol from prior
% work~\cite{KLS},  the prover and verifier may engage in more than one round of
% message passing.

The prover-verifier interaction is parameterized by a predicate (e.g. ``the
transaction $tx$ is committed in the blockchain'').
%
The predicates of interest in our context are predicates on the active
blockchain. Some of the predicates are more suitable for succinct proofs than
others. We focus our attention in \emph{stable} predicates having the property
that all honest miners share their view of them in a way that is updated in a
predictable manner, with a truth-value that persists as the blockchain grows (an
example of an unstable predicate is e.g., the least significant bit of the hash
of last block). Following the work of \cite{backbone}, we wait for $k$ blocks to
bury a block before we consider it \emph{confirmed} and thereby the predicates
depending on it stable. $k$ is the \emph{common prefix} security parameter,
which in Bitcoin folklore is often taken to be $k = 6$.

In our setting, for a given predicate $Q$, several  provers (including
adversarial ones) will generate proofs claiming potentially different truth
values for $Q$ based on their claimed local longest chains. The verifier
receives these proofs and accepts one of the proofs, determining the truth value
of the predicate.  We denote a  \emph{blockchain proof protocol} for a
predicate $Q$ as a pair $(P, V)$ where $P$ is the \emph{prover} and $V$ is the
\emph{verifier}. $P$ is a PPT algorithm that is spawned by a full node when
they wish to produce a proof, accepts as input a full chain $\chain$ and
produces a proof $\pi$ as its output. $V$ is a PPT algorithm which is spawned at
some round (having only Genesis), receives a pair of proofs $(\pi_A, \pi_B)$
from both an honest party and the adversary and returns its decision $d \in \{T,
F\}$ before the next round and terminates. The honest miners produce proofs for
$V$ using $P$, while the adversary produces proofs following some arbitrary
strategy. Before we introduce the security properties for blockchain proof
protocols we introduce some necessary notation for blockchains.

\noindent
\textbf{Notation.}
% Our development makes use of several notation conventions for manipulating
% blockchain data structures, which we introduce here.
Blockchains are finite
block sequences obeying the \emph{blockchain property}: that in every block in
the chain there exists a pointer to its previous block. A chain is
\emph{anchored} if its first block is \emph{genesis}, denoted $Gen$.
For chain addressing we use Python brackets $\chain[\cdot]$ as in
\cite{fruitchains}. A zero-based positive number in a bracket indicates the
indexed block in the chain. A negative index indicates a block from the end,
e.g., $\chain[-1]$ is the tip of the blockchain. A range $\chain[i:j]$ is a
subarray starting from $i$ (inclusive) to j (exclusive).
Given chains $\chain_1, \chain_2$ and blocks $A, Z$ we concatenate them as
$\chain_1 \chain_2$ or $\chain_1 A$. $\chain_2[0]$ must point to $\chain_1[-1]$
and $A$ must point to $\chain_1[-1]$. We denote $\chain\{A:Z\}$ the subarray of
the chain from $A$ (inclusive) to $Z$ (exclusive). We can omit blocks or indices
from either side of the range to take the chain to the beginning or end
respectively.
The \emph{id} function
returns the id of a block given its data, i.e., $\textsf{id} = H(ctr, G(x,
\textsf{interlink}))$.
