\section{Model}

We define our problem in the setting of a blockchain client which is completely
stateless beyond the knowledge of the Genesis block. Without loss of
generality, this single reference block could be any stable checkpoint block,
either hard-coded in the client or obtained through a previous interaction with
the network. However, importantly, the client does not maintain a blockchain.
The challenge is, then, to build a client that is able to communicate with the
network and, without downloading the whole chain headers, is convinced in a
secure manner that a transaction has taken place. We term such a client a
\textit{verifier} and we term \textit{provers} the full nodes it connects to.

The intuition behind these proofs is quite simple: Let $T$ be the mining target
for the network. Then because block ids are generated uniformly at random, half
of the blocks will have an id less than $T / 2$. By having the prover present
to the verifier just these blocks which capture more proof-of-work than their
neighbour counterparts, the verifier is convinced that the proof-of-work of the
ommitted blocks also took place. The same logic can be applied to any
\textit{superblocks} of level $\mu$, namely blocks with id less than $T
2^{-\mu}$.

\subsection{Backbone algorithms}

We assume the verifier will always connect to at least one honest prover. We
now move on to formally define these entities in terms of a mathematical model
which can be used for our analysis.

In order to study the syntax and properties of NIPoPoWs
we abstract their operation in a way that is akin to non-interactive
zero-knowledge proofs (NIZK) \cite{BFM88}. In such protocols, a prover
shares some context with a verifier (called the common reference string).
For a given predicate, the prover computes the proof string and transmits it
to the verifier. The verifier accepts or rejects the string. Given that in our
setting the predicates will be referring to an active evolving chain 
we should define them in the presence of a blockchain protocol. 
Our theoretical abstraction is based on ``backbone'' model of
\cite{backbone} that formalizes the operation of the bitcoin protocol.
We introduce the Prover and the Verifier in
the standard Backbone model as follows. The Prover will extend the functionality
of the miner node. The Verifier will be a completely new entity that can be spawned
by the environment and process a NiPoPow produced by the miner nodes running
the Prover code. Detailed algorithms for the integration with the formal
environment provided by backbone are provided in
Appendix~\ref{sec.appendix-backbone}.

The predicates of interest in our context are predicates on the active blockchain. 
Some of the predicates are more suitable for succinct proofs than others. We focus
our attention in what we call \textit{reliable} predicates; that is,
predicates which are monotonic and stable notions that we define below.  
These predicates have the
exceptional property that all honest miners share their view of them in a way
that is updated in a predictable manner, with a truth-value that persists as the
blockchain grows.  Furthermore, we are interested in \textit{succinct}
predicates, predicates which can be proven using a succinct protocol, a
protocol which requires proofs that are short in terms of the total blockchain
size. Finally, we formalize the notion of non-interactivity.

For blockchain addressing we use the Python range notation of brackets $[~]$.
A positive number in a bracket indicates the indexed block in the blockchain,
starting from zero. A negative number indicates a block indexed from the end. A
range of two numbers separated by a $:$ indicates a subarray starting on the
left index and ending on the right index, inclusive. Omitting one of the range
indices takes it to the beginning or end of the blockchain respectively.

The honest entities that live on the blockchain network are of three kinds:
First, miners, who try to mine new blocks on top of the longest known blockchain and
broadcast their blocks as soon as they are discovered. Second, full nodes,
which maintain the longest blockchain but without mining. Full nodes also act
as the provers in the network, producing proofs by calling a Prove function
which we leave undefined for now, as it is part of the proof protocol. And
third, verifiers or stateless clients, which connect to provers and ask for
proofs in regards to which blockchain is the largest. The verifiers attempt to
determine the value of a predicate on these chains.

A non-interactive proof of proof-of-work protocol is a game between a prover
and a verifier parameterized by predicate $Q$ which the prover tries to
convince the verifier for. The predicate $Q$ is a function of a chain $\chain$,
which the prover claims to be the longest chain.

When asked to do so by the environment, two provers generate proofs $\pi_A$,
$\pi_B$ claiming potentially different truth values for the predicate $Q$ based
on their claimed local longest chains. The verifier receives these proofs and
accepts one of the two proofs, determining the truth value of the predicate. In
this setting, one of the two proofs could be adversarial, as defined in the
security section.

We define a \textit{blockchain proof protocol} for a predicate $Q$ as a pair
$(P, V)$ where $P$ is called the \textit{prover} and $V$ is called the
\textit{verifier}. $P$ is a PPT algorithm that is spawned by a full node
when they wish to produce a proof, accepts as input a full chain $\chain$ and
produces a proof $\pi$ as its output. $V$ is a PPT algorithm which is spawned
by the environment at some round, receives a vector of proofs $\bar{\pi}$ from
both honest parties and the adversary and returns its decision $d \in \{T, F,
\bot\}$ before the next round and terminates. The honest parties produce proofs
for $V$ using $P$.
