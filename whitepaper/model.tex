\section{Model and Definitions}
\label{sec.model}
Our model for describing our results is based on the standard ``backbone'' model
for proof-of-work cryptocurrencies~\cite{backbone}, extended with the widely
used Simplified Payment Verification (SPV) mode due to Nakamoto~\cite{bitcoin}.
We consider three roles in our setting: \emph{lightweight clients},
\emph{full nodes}, and \emph{miners}.

Full nodes and miners run the Bitcoin backbone protocol, maintaining a copy of
the blockchain. Miners commit new transactions they receive from clients.
Clients do not store the entire blockchain, but instead connect to nodes for
service and request up-to-date information about the blockchain, for example
whether a particular payment has been finalized. Our main challenge is to design
a protocol so that clients can sieve through  the responses they receive from
the network and reach a conclusion that should never disagree with the
conclusion of a full  node who is faced with the same objective and infers it
from its local blockchain state.

\subsection{Backbone model}

% AM:
%We define our problem in the setting of a blockchain client which is completely
%stateless beyond the knowledge of a common reference string, the genesis block.
%Without loss of generality, this single reference block could be any stable
%checkpoint block, either hard-coded in the client or obtained through a previous
%interaction with the network.

The entities on the blockchain network are of 3 kinds: (1) miners, who try to
mine new blocks on top of the longest known blockchain and broadcast them as
soon as they are discovered; (2) full nodes, who maintain the longest blockchain
without mining and also act as the provers in the network; (3) verifiers or
stateless clients, who connect to provers and ask for proofs in regards to which
blockchain is the largest. The verifiers attempt to determine the value of a
predicate on these chains. For simplicity we assume that difficulty is constant
and thus the ``longest chain rule'' sufficiently describes honest miner
behavior.

We model proof-of-work discovery attempts by using a random oracle~\cite{RO} as
in \cite{backbone}. For clarity, we present our results in the backbone
model~\cite{backbone}, although we suspect our results transfer easily to more
refined models, such as Pass et al.~\cite{PSS}. More specifically, we remark
that we assume a \emph{synchronous} model in this paper. While we suspect our
results carry over in a treatment in a \emph{partially synchronous} model with
\emph{bounded delay}, this is left for future work.

The random oracle produces $\kappa$-bit strings, where $\kappa$ is the system's
security parameter. The network is synchronized into numbered rounds, which
correspond to moments in time. $n$ denotes the total number of miners in the
game, while $t$ denotes the total number of adversarial miners. Each miner is
assumed to have equal mining power captured by the number of queries $q$
available per player to the random oracle, each query of which succeeds
independently with probability $p$ (a successful query produces a block with
valid proof-of-work). Mining pools and miners of different computing power can
be captured by assuming multiple players combine their computing power. This is
made explicit for the adversary, as they do not incur any network overhead to
achieve communication between adversarial miners. On the contrary, honest
players discovering a block must \textit{diffuse} it (broadcast it) to the
network at a given round and wait for it to be received by the rest of the
honest players at the beginning of the next round. A round during which an
honest block is diffused is called a \textit{successful round}; if the number of
honest blocks diffused is one, it is called \textit{uniquely successful round}.
We assume there is an honest majority, i.e., that $t / n < 0.5$ with a
significant gap~\cite{backbone}. We further assume that the network is
adversarial, but that there is no eclipsing attacks~\cite{heilman2015eclipse}.
More specifically, we allow the adversary to reorder messages transmitted at a
particular round, to inject new messages thereby capturing Sybil attacks~
\cite{sybil}, but not to drop messages. Each honest miner maintains a local
chain $\chain$ which they consider the current active blockchain. Upon receiving
a different blockchain from the network, the current active blockchain is
changed if the received blockchain is longer than the currently adopted one.
Receiving a different blockchain of the same length as the currently adopted one
does not change the adopted blockchain.

Blockchain blocks are generated by including the following data in them: $ctr$,
the nonce used to achieve the proof-of-work; $x$ the Merkle tree~\cite{merkle}
root of the transactions confirmed in this block; and
\textit{interlink}~\cite{KLS}, a vector containing pointers to previous blocks,
including the id of the previous block. The \textit{interlink} data structure
contains pointers to more blocks than just the previous block. We will explain
this further in Section~ \ref{sec.consensus}. Given two hash functions $H$ and
$G$ modelled as random oracles, the id of a block is defined as $\textsf{id} =
H(ctr, G(x, \textsf{interlink}))$. In bitcoin's case, both $H$ and $G$ would be
SHA256.

\subsection{The prover and verifier model}
In our protocol, the nodes include a \emph{proof} along with their responses to
clients. We need to assume that clients are able to connect to at least one
correctly functioning node (i.e., that they cannot be eclipsed from the
network~\cite{heilman2015eclipse,hijackingbitcoin}). Each client makes the same
request to every node, and by verifying the proofs the client identifies the
correct response. Henceforth we will call clients \textit{verifiers} and nodes
\textit{provers}. Note that in the interactive protocol from prior
work~\cite{KLS},  the prover and verifier may engage in more than one round of
message passing.

The prover-verifier interaction is parameterized by a predicate (e.g. ``the
transaction $t$ is committed in the blockchain'').
%
The predicates of interest in our context are predicates on the active
blockchain. Some of the predicates are more suitable for succinct proofs than
others. We focus our attention in \textit{stable} predicates having the property
that all honest miners share their view of them in a way that is updated in a
predictable manner, with a truth-value that persists as the blockchain grows (an
example of an unstable predicate is e.g., the least significant bit of the hash
of last block). Following the work of \cite{backbone}, we wait for $k$ blocks to
bury a block before we consider it \textit{confirmed} and thereby the predicates
depending on it stable. $k$ is the \textit{common prefix} security parameter,
which in bitcoin folklore is often taken to be $k = 6$.

In our setting, for a given predicate $Q$, several  provers (including
adversarial ones) will generate proofs claiming potentially different truth
values for $Q$ based on their claimed local longest chains. The verifier
receives these proofs and accepts one of the proofs, determining the truth value
of the predicate.  We denote a  \textit{blockchain proof protocol} for a
predicate $Q$ as a pair $(P, V)$ where $P$ is the \textit{prover} and $V$ is the
\textit{verifier}. $P$ is a PPT algorithm that is spawned by a full node when
they wish to produce a proof, accepts as input a full chain $\chain$ and
produces a proof $\pi$ as its output. $V$ is a PPT algorithm which is spawned at
some round, receives a pair of proofs $(\pi_A, \pi_B)$ from both an honest party
and the adversary and returns its decision $d \in \{T, F\}$ before the
next round and terminates. The honest miners produce proofs for $V$ using $P$,
while the adversary produces proofs following some arbitrary strategy. Before we
introduce the security properties for blockchain proof protocols we introduce
some necessary notation for blockchains.

\subsection{Blockchain addressing}
Our development makes use of several notation conventions for manipulating
blockchain data structures, which we introduce here. Blockchains are finite
block sequences obeying the \textit{blockchain property}: that in every block in
the chain there exists a pointer to its previous block. A chain is
\textit{anchored} if its first block is \textit{genesis}, denoted $Gen$.

For chain addressing we use Python brackets $\chain[\cdot]$ as in
\cite{fruitchains}. A zero-based positive number in a bracket indicates the
indexed block in the chain. A negative index indicates a block from the end,
e.g., $\chain[-1]$ is the tip of the blockchain. A range $\chain[i:j]$ is a
subarray starting from $i$ (inclusive) to j (exclusive).

Given chains $\chain_1, \chain_2$ and blocks $A, Z$ we concatenate them as
$\chain_1 \chain_2$ or $\chain_1 A$. $\chain_2[0]$ must point to $\chain_1[-1]$
and $A$ must point to $\chain_1[-1]$. We denote $\chain\{A:Z\}$ the subarray of
the chain from $A$ (inclusive) to $Z$ (exclusive). We can omit blocks or indices
from either side of the range to take the chain to the beginning or end
respectively.

The \textit{id} function
returns the id of a block given its data, i.e., $\textsf{id} = H(ctr, G(x,
\textsf{interlink}))$.
